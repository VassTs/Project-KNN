# Project-KNN

Θεοδοσία Παπαδήμα 1115202000162

Γιώργος Κορύλλος 1115202100069

Βασιλική Τσαντήλα 1115201800199

### Οδηγίες εκτέλεσης
Για να τρέξετε την main:
* Μεταφέρεστε στο directory που βρίσκεται το Makefile.
* Εκτελείτε την εντολή: make
* Εκτελείτε την εντολή: ./bin/main <k> <L> <R> <a> <base_file_path> <queries_file_path> <groundtruth_file_path>

πχ 1: ./bin/main 20 40 80 2.0 datasets/siftsmall/siftsmall_base.fvecs datasets/siftsmall/siftsmall_query.fvecs datasets/siftsmall/siftsmall_groundtruth.ivecs

πχ 2: ./bin/main 100 200 60 2.0 datasets/siftsmall/siftsmall_base.fvecs datasets/siftsmall/siftsmall_query.fvecs datasets/siftsmall/siftsmall_groundtruth.ivecs

Για να τρέξετε τα test:
* Μεταφέρεστε στο directory που βρίσκεται το Makefile.
* Εκτελείτε την εντολή: make test
* Εκτελείτε την εντολή: ./bin/test

Για να καθαρίσετε τα αντικείμενα και εκτελέσιμα αρχεία:
* Στο directory που βρίσκεται το Makefile, εκτελείτε την εντολή: make clean

### Διαχωρισμός εργασιών

Το κάθε μέλος ανέλαβε από έναν βασικό αλγόριθμο, καθώς και από έναν αριθμό επιμέρους βοηθητικών συναρτήσεων. Ο καθένας υλοποίησε τα unit tests που αντιστοιχούν στις υλοποιήσεις του.

### Σχεδιαστικές επιλογές

- Υλοποιήθηκε μια πλήρης δομή γράφου (με χρήση adjacency list) με όλες τις λειτουργικότητες που χρειάζονται. Ο κάθε κόμβος και ο κάθε γράφος έχουν id. Τα id των κόμβων ξεκινούν από 0, ενώ των γράφων από 1. Οι κόμβοι με id γράφου 0 δεν ανήκουν σε γράφο.

- Στο αρχείο utility βρίσκονται οι συναρτήσεις για τον υπολογισμό των αποστάσεων, του medoid και μετατροπής σε double.

- Η συνάρτηση εύρεσης του medoid (findMedoid), υλοποιήθηκε με τον ζητούμενο "παραδοσιακό" τρόπο, με μια παραλλαγή ότι υπολογίζει σε ζεύγη τις αποστάσεις, χωρίς να κάνει διπλούς υπολογισμούς, κερδίζοντας, έτσι, πολύ χρόνο (η κλασσική μέθοδος είναι υλοποιημένη σε σχόλια).

- Στους αλγορίθμους GreedySearch, RobustPrune και Vamana ακολουθήθηκε ο ψευδοκώδικας της εκφώνησης.

- Ο αλγόριθμος Vamana χρησιμοποιεί μια συνάρτηση γεννήτρια γράφου, η οποία προσθέτει R τυχαίες ακμές σε κάθε κόμβο. Επίσης, επιστρέφει την τιμή του medoid, η οποία θα χρειαστεί ώστε να κληθεί σωστά ο GreedySearch στην main.

- O Vamana δίνει στην main έναν γράφο του οποίου οι κόμβοι είναι συνδεδεμένοι με τους κοντινότερους γείτονές τους (το πολύ R) και στη συνέχεια η main καλεί τον GreedySearch για κάθε δοσμένο query με start node medoid, ώστε να βρει τους k κοντινότερους γείτονές του στον γράφο αυτό.

### Αποτελέσματα & Χρόνοι (Παραδείγματα)

Δίνοντας την siftsmall βάση και τις παρακάτω τιμές σε δύο διαφορετικούς υπολογιστές και στα linux της σχολής έχουμε τους εξής χρόνους:

* PC 1:
  * k = 20, L = 40, R = 80, a = 2.0: 964.066 seconds or 16.0678 minutes με accuracy 99.6%
  * k = 100, L = 200, R = 60, a = 2.0: 640.234 seconds  10.6706 minutes με accuracy 97.89%

* PC 2:
  * k = 20, L = 40, R = 80, a = 2.0: 1428.65 seconds or 23.8109 minutes με accuracy 99.9%
  * k = 100, L = 200, R = 60, a = 2.0: 1085.12 seconds or 18.0853 minutes με accuracy 98.84%
 
* Linux Σχολής (linux14.di.uoa.gr):
  * k = 20, L = 40, R = 80, a = 2.0:
  * k = 100, L = 200, R = 60, a = 2.0:

Δεν υπάρχουν διαρροές μνήμης.
